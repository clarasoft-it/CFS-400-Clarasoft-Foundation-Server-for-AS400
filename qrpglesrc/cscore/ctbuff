
      *===================================================================
      * Package: CTBASE
      * Class:   CTBUFF
      * Source:  Implementation
      * Version: 01.00.00
      *
      * Dependencies:
      *
      *     CTBASE::CTLST, Version 1.00.00
      *     CTBASE::CTBUFFLST, Version 1.00.00
      *
      * ------------------------------------------------------------------
      * Copyright 2013 Clarasoft I.T. Solutions Inc.
      *===================================================================

     H NOMAIN

      /COPY CTBASEH

     DCTBUFF_MAX_NODESIZE...
     D                 C                   Const(65535)

     DCTBUFF_PRIVATE_ClearBuffer...
     D                 PR            10I 0
     D@Buff                            *   Value
     D@Char                           3U 0 Value
     D@Len                           10I 0 Value

     DCTBUFF_PRIVATE_ClearTokens...
     D                 PR            10I 0
     D@This                            *   Value

     DCTBUFF_PRIVATE_MemCmp...
     D                 PR            10I 0 ExtProc('memcmp')
     D@S1                              *   Value
     D@S2                              *   Value
     D@Len                           10I 0 Value

     DCTBUFF_PRIVATE_MemCpy...
     D                 PR                  ExtProc('memcpy')
     D@To                              *   Value
     D@From                            *   Value
     D@Len                           10I 0 Value

     DCTBUFF_PRIVATE_MemSet...
     D                 PR                  ExtProc('memset')
     D@To                              *   Value
     D@Char                           3U 0 Value
     D@Len                           10I 0 Value
     
     DCTBUFFLST_PRIVATE_ClearBuffers...
     D                 PR            10I 0
     D@This                            *   Value

     DCTBUFFLST_PRIVATE_MemCpy...
     D                 PR                  ExtProc('memcpy')
     D@To                              *   Value
     D@From                            *   Value
     D@Len                           10I 0 Value

     DCTBUFFLST_Token  DS                  Based(Null)
     D                                     Qualified
     DLen                            10I 0
     DToken                            *

     DCTBUFFLST_Instance...
     D                 DS                  Based(Null)
     D                                     Qualified
     DStrings                          *

     DCTBUFF_Token     DS                  Based(Null)
     D                                     Qualified
     DLen                            10I 0
     DToken                            *

     DCTBUFF_Instance  DS                  Based(Null)
     D                                     Qualified
     DLen                            10I 0
     DTokens                           *
     DCurAbsPos                      10I 0
     DCurRelPos                      10I 0
     DCurNode                        10I 0

      * ------------------------------------------------------------------

     PCTBUFF_BuffCat   B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Buff                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DInstance2        DS                  LikeDs(CTBUFF_Instance) Based(@Buff)
     DTrgToken         DS                  LikeDs(CTBUFF_Token)
     DSrcToken         DS                  LikeDs(CTBUFF_Token)
     DCount            S             10I 0
     DCount2           S             10I 0
     DBytes            S             10I 0
     DBytesAvail       S             10I 0
     DSrcOffset        S             10I 0
     DTrgOffset        S             10I 0
     DCpyLen           S             10I 0
     Dn                S             10I 0
     DRc               S             10I 0
     DLen              S             10I 0
     DLeftOverToken    S               N
     DSelfCopy         S               *

      /Free

         If Instance.Len = 0;
           Return CTBUFF_BuffSet(@This: @Buff);
         EndIf;

         If @Buff = *Null;
           Return Instance.Len;
         EndIf;

         If Instance2.Len = 0;
           Return Instance.Len;
         EndIf;

         If @This = @Buff;
           // Concatenating to self ... to avoid problems,
           // make a copy of yourself and concatenate copy
           SelfCopy = CTBUFF_Constructor();
           CTBUFF_BuffSet(SelfCopy: @This);
           Rc = CTBUFF_BuffCat(@This: SelfCopy);
           CTBUFF_Destructor(SelfCopy);
           Return Rc;
         EndIf;

         Count = CTLST_Count(Instance.Tokens);
         Count2 = CTLST_Count(Instance2.Tokens);

         Bytes = %Size(TrgToken);
         CTLST_Get(Instance.Tokens:
                   %Addr(TrgToken): Bytes: Count);

         If TrgToken.Len < CTBUFF_MAX_NODESIZE;

           // How much room left in last target token?
           BytesAvail = CTBUFF_MAX_NODESIZE - TrgToken.Len;
           // Get source token
           Bytes = %Size(SrcToken);
           n = 1;
           CTLST_Get(Instance2.Tokens:
                       %Addr(SrcToken): Bytes: n);

           If SrcToken.Len <= BytesAvail;
             //Source buffer can fit entirely in target's last token

             CTBUFF_PRIVATE_MemCpy(TrgToken.Token + TrgToken.Len:
                                      SrcToken.Token: BytesAvail);

             TrgToken.Len += SrcToken.Len;
             Instance.Len += SrcToken.Len;
             Bytes = %Size(TrgToken);
             CTLST_Set(Instance.Tokens: %Addr(TrgToken):
                                        Bytes: CTLST_BOTTOM);

           Else;

             // Copy to target token as much as possible

             CTBUFF_PRIVATE_MemCpy(TrgToken.Token + TrgToken.Len:
                                   SrcToken.Token: BytesAvail);

             TrgToken.Len += BytesAvail;
             Instance.Len += BytesAvail;
             Bytes = %Size(TrgToken);
             CTLST_Set(Instance.Tokens: %Addr(TrgToken):
                                        Bytes: CTLST_BOTTOM);

             // We must now append the rest of the source buffer
             SrcOffset = BytesAvail;

             BytesAvail = 0;
             Dow 1=1;

               If BytesAvail = 0;
                 TrgOffset = 0;
                 BytesAvail = CTBUFF_MAX_NODESIZE;
                 TrgToken.Len = 0;
                 TrgToken.Token = %Alloc(CTBUFF_MAX_NODESIZE);
                 LeftOverToken = *On;
               EndIf;

               If (SrcToken.Len - SrcOffset) > BytesAvail;
                 CpyLen = BytesAvail;
               Else;
                 CpyLen = SrcToken.Len - SrcOffset;
               EndIf;

               CTBUFF_PRIVATE_MemCpy(TrgToken.Token + TrgOffset:
                                     SrcToken.Token + SrcOffset:
                                     CpyLen);

               TrgToken.Len += CpyLen;
               Instance.Len += CpyLen;

               If TrgToken.Len = CTBUFF_MAX_NODESIZE;
                 CTLST_Insert(Instance.Tokens: %Addr(TrgToken):
                              %Size(TrgToken): CTLST_BOTTOM);
                 LeftOverToken = *Off;
               EndIf;

               // Decrease available space in target node correspondingly
               BytesAvail -= CpyLen;

               TrgOffset += CpyLen;
               SrcOffset += CpyLen;

               If SrcOffset >= SrcToken.Len;
                 // Fetch next source token
                 n += 1;
                 If n > Count2;
                   Leave;
                 Else;
                   Bytes = %Size(TrgToken);
                   Rc = CTLST_Get(Instance2.Tokens: %Addr(SrcToken):
                                             Bytes: n);
                   If Rc = CS_FAILURE;
                     Leave;
                   Else;
                     SrcOffset = 0;
                   EndIf;
                 EndIf;

               EndIf;

             EndDo;

             If LeftOverToken = *On;
               CTLST_Insert(Instance.Tokens: %Addr(TrgToken):
                            %Size(TrgToken): CTLST_BOTTOM);
             EndIf;

           EndIf;

         Else;

           // Last token is completely filled. This means we simply
           // add source tokens at the end of the target token list

           For n=1 To Count2 By 1;
             Bytes = %Size(TrgToken);
             Rc = CTLST_Get(Instance2.Tokens: %Addr(SrcToken):
                                             Bytes: n);
             TrgToken.Len = SrcToken.Len;
             TrgToken.Token = %Alloc(CTBUFF_MAX_NODESIZE);

             CTBUFF_PRIVATE_MemCpy(TrgToken.Token:
                                   SrcToken.Token:
                                   SrcToken.Len);

             Instance.Len += SrcToken.Len;

             CTLST_Insert(Instance.Tokens: %Addr(TrgToken):
                          %Size(TrgToken): CTLST_BOTTOM);

           EndFor;

         EndIf;

         Return Instance.Len;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_BuffComp...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Buff                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DInstance2        DS                  LikeDs(CTBUFF_Instance) Based(@Buff)
     DS1Token          DS                  LikeDs(CTBUFF_Token)
     DS2Token          DS                  LikeDs(CTBUFF_Token)
     DCount            S             10I 0
     DTokenCount       S             10I 0
     DTokenCount2      S             10I 0
     DLen              S             10I 0
     Dn                S             10I 0
     DRc               S             10I 0
     DBytes            S             10I 0

      /Free

         TokenCount = CTLST_Count(Instance.Tokens);
         TokenCount2 = CTLST_Count(Instance2.Tokens);

         // Take the smaller of the two counts
         If TokenCount < TokenCount2;
           Count = TokenCount;
         Else;
           Count = TokenCount2;
         EndIf;

         For n=1 To Count By 1;

           Bytes = %Size(CTBUFF_Token);
           CTLST_Get(Instance.Tokens: %Addr(S1Token):
                     Bytes: n);

           Bytes = %Size(CTBUFF_Token);
           CTLST_Get(Instance2.Tokens: %Addr(S2Token):
                     Bytes: n);

           If S1Token.Len = S2Token.Len;

             Rc = CTBUFF_PRIVATE_MemCmp(S1Token.Token:
                                        S2Token.Token:
                                        S1Token.Len);

             If Rc <> 0;
               Return Rc;
             EndIf;

           Else;

             If S1Token.Len > S2Token.Len;
               Rc = CTBUFF_PRIVATE_MemCmp(S1Token.Token:
                                          S2Token.Token:
                                          S2Token.Len);
               If Rc = 0;
                 Return 1;
               Else;
                 Return -1;
               EndIf;
             Else;
               Rc = CTBUFF_PRIVATE_MemCmp(S1Token.Token:
                                          S2Token.Token:
                                          S1Token.Len);
               If Rc = 0;
                 Return -1;
               Else;
                 Return 1;
               EndIf;
             EndIf;

           EndIf;

         EndFor;

         // If you get here, then all your tokens are identical
         // If both buffers are the same size, then they are
         // the same, else, the longer is higher

         If TokenCount > TokenCount2;
           Return 1;
         Else;
           If TokenCount < TokenCount2;
             Return -1;
           EndIf;
         EndIf;

         Return 0;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_BuffSet   B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Buff                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DInstance2        DS                  LikeDs(CTBUFF_Instance) Based(@Buff)
     DToken            DS                  LikeDs(CTBUFF_Token)
     DNewToken         DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DCount            S             10I 0
     DBytes            S             10I 0
     DLeftLen          S             10I 0
     DRightLen         S             10I 0
     DpNewToken        S               *

      /Free

         If @This = @Buff;
           // Trying to copy to self;
           Return CS_SUCCESS;
         EndIf;

         CTBUFF_Set(@This: *Null: 0);

         Count = CTLST_Count(Instance2.Tokens);

         For n=1 To Count By 1;

           Bytes = %Size(CTBUFF_Token);
           CTLST_Get(Instance2.Tokens: %Addr(Token):
                     Bytes: n);

           NewToken.Len = Token.Len;
           NewToken.Token = %Alloc(CTBUFF_MAX_NODESIZE);
           CTBUFF_PRIVATE_MemCpy(NewToken.Token: Token.Token:
                                                Token.Len);

           Instance.Len = Instance.Len + Token.Len;

           CTLST_Insert(Instance.Tokens:
                        %Addr(NewToken):
                        %Size(NewToken):
                        CTLST_BOTTOM);

         EndFor;

         Return Instance.Len;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_ByteAt...
     P                 B                   EXPORT
     D                 PI             3U 0
     D@This                            *   Value
     D@Index                         10I 0 Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DRc               S             10I 0
     DBytes            S             10I 0
     DTotalLen         S             10I 0
     DNumTokens        S             10I 0
     DpChar            S               *
     DLen              S             10I 0
     DOffset           S             10I 0
     DCharValue        S              3U 0 Based(pChar)

      /Free

        pChar = *Null;

        If (@Index > Instance.Len Or @Index < 1);
          Return x'FF';
        Else;
          TotalLen = 0;
          TotalLen = 0;
          NumTokens = CTLST_Count(Instance.Tokens);
          For n=1 To NumTokens;
            Bytes = %Size(Token);
            CTLST_Get(Instance.Tokens:
                      %Addr(Token):
                      Bytes:
                      n);

            TotalLen += Token.Len;
            If (@Index <= TotalLen);
              Offset = Token.Len - (TotalLen - @Index);
              pChar = (Token.Token + Offset) - 1;
              Return CharValue;
            EndIf;
          EndFor;
        EndIf;

        Return x'FF';
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Cat       B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Len                           10I 0 Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     DNewToken         DS                  LikeDs(CTBUFF_Token)
     DCount            S             10I 0
     Dn                S             10I 0
     DNumTokens        S             10I 0
     DBytes            S             10I 0
     DLeftLen          S             10I 0
     DRightLen         S             10I 0
     DOffset           S             10I 0
     DLeftOver         S             10I 0
     DpNewToken        S               *

      /Free

         If (@Str <> *Null And @Len <> 0);

           Count = CTLST_Count(Instance.Tokens);

           If Count = 0;

             // This is like setting the buffer
             CTBUFF_Set(@This: @Str: @Len);

           Else;

             Bytes = %Size(Token);
             CTLST_Get(Instance.Tokens:
                           %Addr(Token): Bytes: Count);

             If (Token.Len + @Len) > CTBUFF_MAX_NODESIZE;

               // Fill last token first

               NewToken.Token = %Alloc(CTBUFF_MAX_NODESIZE);

               LeftLen      = CTBUFF_MAX_NODESIZE - Token.Len;
               RightLen     = @Len - LeftLen;
               NewToken.Len = RightLen;

               If LeftLen > 0;
                 CTBUFF_PRIVATE_MemCpy((Token.Token + Token.Len):
                                        @Str: LeftLen);

                 Token.Len   = CTBUFF_MAX_NODESIZE;
                 CTLST_Set(Instance.Tokens:
                               %Addr(Token): %Size(Token): CTLST_BOTTOM);
                 Instance.Len = Instance.Len + LeftLen;
               EndIf;

               NumTokens = %Div((@Len - LeftLen): CTBUFF_MAX_NODESIZE);
               LeftOver = (@Len - LeftLen) -
                          (NumTokens * CTBUFF_MAX_NODESIZE);
               Offset = LeftLen;

               For n=1 To NumTokens By 1;

                 Token.Len = CTBUFF_MAX_NODESIZE;
                 Token.Token = %Alloc(CTBUFF_MAX_NODESIZE);
                 CTBUFF_PRIVATE_MemCpy(Token.Token: @Str + Offset:
                                                CTBUFF_MAX_NODESIZE);

                 Instance.Len = Instance.Len + CTBUFF_MAX_NODESIZE;

                 CTLST_Insert(Instance.Tokens:
                              %Addr(Token):
                              %Size(Token):
                              CTLST_BOTTOM);

                 Offset += CTBUFF_MAX_NODESIZE;

               EndFor;

               Token.Len = LeftOver;
               Token.Token = %Alloc(CTBUFF_MAX_NODESIZE);
               CTBUFF_PRIVATE_MemCpy(Token.Token:
                                        @Str + Offset: LeftOver);

               Instance.Len = Instance.Len + LeftOver;

               Token.Len   = LeftOver;

               CTLST_Insert(Instance.Tokens:
                            %Addr(Token):
                            %Size(Token):
                            CTLST_BOTTOM);

             Else;

               CTBUFF_PRIVATE_MemCpy((Token.Token + Token.Len):
                                    @Str: @Len);

               Token.Len = Token.Len + @Len;

               CTLST_Set(Instance.Tokens:
                             %Addr(Token): %Size(Token): CTLST_BOTTOM);

               Instance.Len = Instance.Len + @Len;

             EndIf;

           EndIf;

         Else;

         EndIf;

         Return Instance.Len;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Comp...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Len                           10I 0 Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     DCount            S             10I 0
     DBytes            S             10I 0
     DOffset           S             10I 0
     DCompLen          S             10I 0
     DBytesLeft        S             10I 0
     DRc               S             10I 0
     Dn                S             10I 0

      /Free

         If @Str = *Null;
           If Instance.Len = 0;
             Return 0;
           Else;
             Return 1;
           EndIf;
         EndIf;

         If Instance.Len = 0;
           Return -1;
         EndIf;

         // If you get here, then we have two buffers

         Count = CTLST_Count(Instance.Tokens);
         Offset = 0;
         BytesLeft = @Len;
         For n=1 To Count By 1;

           Bytes = %Size(CTBUFF_Token);
           CTLST_Get(Instance.Tokens: %Addr(Token):
                     Bytes: n);

           If Token.Len > BytesLeft;
             CompLen = BytesLeft;
           Else;
             If Token.Len < BytesLeft;
               CompLen = Token.Len;
             EndIf;
           EndIf;

           Rc = CTBUFF_PRIVATE_MemCmp(Token.Token:
                                      @Str + Offset:
                                      CompLen);

           If Rc <> 0;
             Return Rc;
           EndIf;

           BytesLeft -= CompLen;
           OffSet += CompLen;

         EndFor;

         // If you get here, then all your tokens are identical
         // If both buffers are the same size, then they are
         // the same, else, the longer is higher

         If Instance.Len > @Len;
           Return 1;
         Else;
           If Instance.Len < @Len;
             Return -1;
           EndIf;
         EndIf;

         Return 0;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Constructor...
     P                 B                   EXPORT
     D                 PI              *

     DThis             S               *
     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(This)

      /Free

          This = %Alloc(%Size(CTBUFF_Instance));

          Instance.Len = 0;
          Instance.Tokens = CTLST_Constructor();

          Instance.CurAbsPos = 0;
          Instance.CurRelPos = 0;
          Instance.CurNode   = 0;

          Return This;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Destructor...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DBytes            S             10I 0
     DNumTokens        S             10I 0

      /Free

         CTBUFF_PRIVATE_ClearTokens(@This);
         CTLST_Destructor(Instance.Tokens);
         Dealloc @This;
         Return CS_SUCCESS;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Get       B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@From                          10I 0 Value
     D@Len                           10I 0

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     DBytes            S             10I 0
     Dn                S             10I 0
     Dk                S             10I 0
     DNumTokens        S             10I 0
     DTokenLen         S             10I 0
     DStrLen           S             10I 0
     DRemain           S             10I 0
     DCurIndex         S             10I 0
     DOffset           S             10I 0
     DCpyLen           S             10I 0
     DRight            S             10I 0
     DStartIndex       S             10I 0
     DRc               S             10I 0

      /Free

         If (@From < 1);
           @Len = 0;
           Return CS_FAILURE;
         EndIf;

         If (Instance.Len <= 0);
           @Len = 0;
           Return CS_FAILURE;
         EndIf;

         StrLen = 0;
         If (@From <= Instance.Len);
           If (@Len <= 0);
             @Len = Instance.Len - @From + 1;
           Else;
             If (@Len > (Instance.Len - @From + 1));
               @Len = Instance.Len - @From + 1;
             EndIf;
           EndIf;
           CurIndex = 0;
           NumTokens = CTLST_Count(Instance.Tokens);
           For n=1 To NumTokens;
             Bytes = %Size(Token);
             CTLST_Get(Instance.Tokens:
                       %Addr(Token):
                       Bytes:
                       n);
             StrLen += Token.Len;
             If StrLen >= @From;
               If (@From + @Len - 1) <= StrLen;
                 CpyLen = @Len;
               Else;
                 CpyLen = StrLen - @From + 1;
               EndIf;
               Offset = Token.Len - (StrLen - @From) - 1;
               CurIndex = CpyLen;
               CTBUFF_PRIVATE_MemCpy(@Str:
                                    Token.Token + Offset: CpyLen);
               Leave;
             EndIf;
           EndFor;

           Remain = @Len - CpyLen;

           If (Remain > 0);
             For k=n+1 To NumTokens;
               Bytes = %Size(Token);
               CTLST_Get(Instance.Tokens:
                         %Addr(Token):
                         Bytes:
                         k);

               If (Token.Len >= Remain);
                 CTBUFF_PRIVATE_MemCpy(@Str+CurIndex: Token.Token: Remain);
                 StrLen += Remain;
                 CurIndex += Remain;
                 Remain = 0;
                 Leave;
               Else;
                 CTBUFF_PRIVATE_MemCpy(@Str+CurIndex:
                                        Token.Token: Token.Len);
                 StrLen += Token.Len;
                 CurIndex += Token.Len;
                 Remain = Remain - Token.Len;
               EndIf;

             EndFor;
           EndIf;
         Else;
           @Len = 0;
           Return CS_FAILURE;
         EndIf;
         Return CS_SUCCESS;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Length    B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)

      /Free
         Return Instance.Len;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Search    B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@TestStr                         *   Value
     D@Len                           10I 0 Value
     D@Indices                         *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     DTokenPos         S               *
     DTokenChar        S              1A   Based(TokenPos)
     DTestPos          S               *
     DTestChar         S              1A   Based(TestPos)
     DTestIndex        S             10I 0
     Di                S             10I 0
     Dj                S             10I 0
     Dk                S             10I 0
     Dn                S             10I 0
     DNumTokens        S             10I 0
     DIndex            S             10I 0
     DFound            S             10I 0
     DMatchIndex       S             10I 0
     DBytes            S             10I 0
     DRc               S             10I 0

      /Free
        Rc = CS_FAILURE;
        NumTokens = CTLST_Count(Instance.Tokens);
        CTLST_Clear(@Indices);

        TestPos = @TestStr;

        TestIndex = 1;
        Index = 1;
        MatchIndex = 1;

        For n=1 To NumTokens;
          Bytes = %Size(Token);
          CTLST_Get(Instance.Tokens:
                    %Addr(Token):
                    Bytes:
                    n);

          TokenPos = Token.Token;
          For i=1 To Token.Len;

            If TestChar = TokenChar;
              If MatchIndex = 1;
                Found = Index;
                If MatchIndex = @Len;
                  CTLST_Insert(@Indices:
                               %Addr(Found):
                               %Size(Found):
                               CTLST_BOTTOM);
                  MatchIndex = 1;
                  TestPos = @TestStr;
                  Rc = CS_SUCCESS;
                Else;
                  MatchIndex += 1;
                  TestPos += 1;
                EndIf;
              Else;
                If MatchIndex = @Len;
                  CTLST_Insert(@Indices:
                               %Addr(Found):
                               %Size(Found):
                               CTLST_BOTTOM);
                  MatchIndex = 1;
                  TestPos = @TestStr;
                  Rc = CS_SUCCESS;
                Else;
                  MatchIndex += 1;
                  TestPos += 1;
                EndIf;
              EndIf;
            Else;
              MatchIndex = 1;
              TestPos = @TestStr;
            EndIf;
            TokenPos += 1;
            Index += 1;
          EndFor;
        EndFor;
        Return Rc;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Set       B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Len                           10I 0 Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DBytes            S             10I 0
     DNumTokens        S             10I 0
     DLeftOver         S             10I 0
     DOffset           S             10I 0

      /Free

         CTBUFF_PRIVATE_ClearTokens(@This);

         If (@Str <> *Null And @Len <> 0);

           NumTokens = %Div(@Len: CTBUFF_MAX_NODESIZE);
           LeftOver = @Len - (NumTokens * CTBUFF_MAX_NODESIZE);
           Offset = 0;
           For n=1 To NumTokens By 1;

             Token.Len = CTBUFF_MAX_NODESIZE;
             Token.Token = %Alloc(CTBUFF_MAX_NODESIZE);
             CTBUFF_PRIVATE_MemCpy(Token.Token: @Str + Offset:
                                                CTBUFF_MAX_NODESIZE);
             Instance.Len = Instance.Len + CTBUFF_MAX_NODESIZE;

             CTLST_Insert(Instance.Tokens:
                          %Addr(Token):
                          %Size(Token):
                          CTLST_BOTTOM);

             Offset += CTBUFF_MAX_NODESIZE;

           EndFor;

           // Copy left over data
           If LeftOver > 0;
             Token.Len = LeftOver;
             Token.Token = %Alloc(CTBUFF_MAX_NODESIZE);
             CTBUFF_PRIVATE_MemCpy(Token.Token: @Str+ Offset: LeftOver);
             Instance.Len = Instance.Len + LeftOver;

             CTLST_Insert(Instance.Tokens:
                          %Addr(Token):
                          %Size(Token):
                          CTLST_BOTTOM);
           EndIf;

         Else;
           Instance.Len = 0;
         EndIf;

         Return Instance.Len;

      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_Split     B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Separator                       *   Value
     D@SepLen                        10I 0 Value
     D@Tokens                          *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DRc               S             10I 0
     DCount            S             10I 0
     DBytes            S             10I 0
     DCurIndex         S             10I 0
     DNextIndex        S             10I 0
     DTokenLen         S             10I 0
     DpIndices         S               *
     DBuff             S               *

      /Free

         Rc = CS_SUCCESS;

         pIndices = CTLST_Constructor();

         CTBUFFLST_Clear(@Tokens);

         CTBUFF_Search(@This: @Separator: @SepLen: pIndices);
         Count = CTLST_Count(pIndices);

         If Count > 0;
           Bytes = %Size(CurIndex);
           CTLST_Get(pIndices: %Addr(CurIndex): Bytes: n);

           If (CurIndex > 1);
             Token.Len = CurIndex-1;
             Buff = %Alloc(Token.Len);
             Token.Token = Buff;
             Bytes = CTBUFF_Get(@This: Buff: 1: Token.Len);
           Else;
             Token.Token = *Null;
             Token.Len = 0;
           EndIf;

           CTBUFFLST_InsertValue(@Tokens: Token.Token:
                                      Token.Len: CTLST_BOTTOM);

           For n=2 To Count By 1;
             Bytes = %Size(NextIndex);
             CTLST_Get(pIndices: %Addr(NextIndex): Bytes: n);
             If (NextIndex - CurIndex > @SepLen);
               TokenLen = NextIndex - CurIndex - @SepLen;
               Buff = %Alloc(TokenLen);
               Token.Token = Buff;
               Token.Len = TokenLen;
               Bytes = CTBUFF_Get(@This: Buff: CurIndex + @SepLen:
                                                 TokenLen);
             Else;
               Token.Token = *Null;
               Token.Len = 0;
             EndIf;
             CTBUFFLST_InsertValue(@Tokens: Token.Token:
                                      Token.Len: CTLST_BOTTOM);
             CurIndex = NextIndex;
           EndFor;

           If ( (CurIndex + @SepLen) <= Instance.Len);
             TokenLen = Instance.Len - CurIndex - @SepLen + 1;
             Buff = %Alloc(TokenLen);
             Token.Token = Buff;
             Token.Len = TokenLen;
             Bytes = CTBUFF_Get(@This: Buff:
                                       CurIndex + @SepLen: TokenLen);
           Else;
             Token.Token = *Null;
             Token.Len = 0;
           EndIf;

           CTBUFFLST_InsertValue(@Tokens: Token.Token:
                                    Token.Len: CTLST_BOTTOM);

         EndIf;

         CTLST_Destructor(pIndices);
         Return Rc;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_PRIVATE_ClearBuffer...
     P                 B
     D                 PI            10I 0
     D@Buff                            *   Value
     D@Char                           3U 0 Value
     D@Len                           10I 0 Value

      /Free
        CTBUFF_PRIVATE_MemSet(@Buff: @Char: @Len);
        Return CS_SUCCESS;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFF_PRIVATE_ClearTokens...
     P                 B
     D                 PI            10I 0
     D@This                            *   Value

     DInstance         DS                  LikeDs(CTBUFF_Instance) Based(@This)
     DToken            DS                  LikeDs(CTBUFF_Token)
     Dn                S             10I 0
     DBytes            S             10I 0
     DNumTokens        S             10I 0

      /Free

        NumTokens = CTLST_Count(Instance.Tokens);
        For n=1 To NumTokens;
           Bytes = %Size(Token);
           CTLST_Get(Instance.Tokens:
                     %Addr(Token):
                     Bytes:
                     n);
           If (Token.Token <> *Null);
             Dealloc Token.Token;
           EndIf;
        EndFor;
        Instance.Len = 0;
        CTLST_Clear(Instance.Tokens);
        Return CS_SUCCESS;
      /End-Free

     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_Constructor...
     P                 B                   EXPORT
     D                 PI              *

     D#This            S               *
     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(#This)

      /Free

         #This = %Alloc(%Size(CTBUFFLST_Instance));
         #Instance.Strings = CTLST_Constructor();
         Return #This;

      /End-Free
     P                 E

     PCTBUFFLST_Destructor...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)

      /Free

         CTBUFFLST_PRIVATE_ClearBuffers(@This);
         CTLST_Destructor(#Instance.Strings);
         Dealloc @This;
         Return CS_SUCCESS;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_Clear...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)

      /Free

         CTBUFFLST_PRIVATE_ClearBuffers(@This);
         Return CS_SUCCESS;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_BuffLength...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Bytes           S             10I 0

      /Free

         #Bytes = %Size(#Token);
         #Rc = CTLST_Get(#Instance.Strings:
                            %Addr(#Token): #Bytes: @Index);
         If #Rc = CS_SUCCESS;
           Return #Token.Len;
         EndIf;
         Return 0;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_InsertValue...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Size                          10I 0 Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)

      /Free

         If (@Size > 0);
            #Token.Token = %Alloc(@Size);
            CTBUFFLST_PRIVATE_memCpy(#Token.Token: @Str: @Size);
         Else;
            #Token.Token = *Null;
         EndIf;
         #Token.Len = @Size;
         CTLST_Insert(#Instance.Strings:
                         %Addr(#Token): %Size(CTBUFFLST_Token): @Index);

         Return CS_SUCCESS;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_InsertBuffer...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@StrObj                          *   Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0

      /Free

         If @StrObj <> *Null;
           #Token.Len = CTBUFF_Length(@StrObj);
           If #Token.Len > 0;
             #Token.Token = %Alloc(#Token.Len);
             #Rc = CTBUFF_Get(@StrObj: #Token.Token: 1: #Token.Len);
           Else;
             #Token.Token = *Null;
           EndIf;
         Else;
           #Token.Len = 0;
           #Token.Token = *Null;
         EndIf;

         #Rc = CTLST_Insert(#Instance.Strings:
                         %Addr(#Token): %Size(CTBUFFLST_Token): @Index);

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_Remove...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Bytes           S             10I 0

      /Free

         #Bytes = %Size(#Token);
         #Rc = CTLST_Get(#Instance.Strings:
                            %Addr(#Token): #Bytes: @Index);
         If #Rc = CS_SUCCESS;
           Dealloc #Token.Token;
           CTLST_Remove(#Instance.Strings: @Index);
         EndIf;

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_Count...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
      /Free

         Return CTLST_Count(#Instance.Strings);

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_SetBuffer...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@StrObj                          *   Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Bytes           S             10I 0
     D#Buffer          S               *

      /Free

         If (@StrObj <> *Null);
           #Bytes = CTBUFF_Length(@StrObj);
           #Buffer = %Alloc(#Bytes);
           #Rc = CTBUFF_Get(@StrObj: #Buffer: 1: #Bytes);
           #Rc = CTBUFFLST_SetValue(@This: #Buffer: #Bytes: @Index);
           Dealloc #Buffer;
         Else;
           #Rc = CTBUFFLST_SetValue(@This: *Null: 0: @Index);
         EndIf;

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_SetValue...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Size                          10I 0 Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Bytes           S             10I 0

      /Free

         #Bytes = %Size(#Token);
         #Rc = CTLST_Get(#Instance.Strings:
                            %Addr(#Token): #Bytes: @Index);
         If #Rc = CS_SUCCESS;
           Dealloc #Token.Token;
           If (@Str <> *Null And @Size > 0);
             #Token.Token = %Alloc(@Size);
             #Token.Len = @Size;
             CTBUFFLST_PRIVATE_MemCpy(#Token.Token: @Str: @Size);
           Else;
             #Token.Token = *Null;
             #Token.Len = 0;
           EndIf;

           #Rc = CTLST_Set(#Instance.Strings:
                           %Addr(#Token): %Size(#Token): @Index);

         EndIf;

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_GetBuffer...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@StrObj                          *   Value
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Size            S             10I 0

      /Free

         If (@StrObj = *Null);
           Return CS_FAILURE;
         EndIf;
         #Size = %Size(CTBUFFLST_Token);
         #Rc = CTLST_Get(#Instance.Strings:
                             %Addr(#Token) :#Size: @Index);
         If #Rc = CS_SUCCESS;
           If (#Token.Len > 0);
             #Rc = CTBUFF_Set(@StrObj: #Token.Token: #Token.Len);
           Else;
             #Rc = CTBUFF_Set(@StrObj: *Null: 0);
           EndIf;
         Else;
           #Rc = CTBUFF_Set(@StrObj: *Null: 0);
         EndIf;

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_GetValue...
     P                 B                   EXPORT
     D                 PI            10I 0
     D@This                            *   Value
     D@Str                             *   Value
     D@Size                          10I 0
     D@Index                         10I 0 Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#Rc              S             10I 0
     D#Bytes           S             10I 0

      /Free

         If (@Str = *Null Or @Size = 0);
           Return CS_FAILURE;
         EndIf;

         #Bytes = %Size(CTBUFFLST_Token);
         #Rc = CTLST_Get(#Instance.Strings:
                            %Addr(#Token): #Bytes: @Index);

         If #Rc = CS_SUCCESS;

           If #Token.Len > 0;
             If (@Size > #Token.Len);
               CTBUFFLST_PRIVATE_MemCpy(@Str: #Token.Token: #Token.Len);
             Else;
               CTBUFFLST_PRIVATE_MemCpy(@Str: #Token.Token: @Size);
             EndIf;
             @Size = #Token.Len;
           Else;
             @Size = 0;
           EndIf;
         Else;
           @Size = 0;
         EndIf;

         Return #Rc;

      /End-Free
     P                 E

      * ------------------------------------------------------------------

     PCTBUFFLST_PRIVATE_ClearBuffers...
     P                 B
     D                 PI            10I 0
     D@This                            *   Value

     D#Instance        DS                  LikeDs(CTBUFFLST_Instance)
     D                                     Based(@This)
     D#Token           DS                  LikeDs(CTBUFFLST_Token)
     D#n               S             10I 0
     D#Bytes           S             10I 0
     D#NumTokens       S             10I 0

      /Free

        #NumTokens = CTLST_Count(#Instance.Strings);
        For #n=1 To #NumTokens;
           #Bytes = %Size(#Token);
           CTLST_Get(#Instance.Strings:
                        %Addr(#Token):
                        #Bytes:
                        #n);
           If (#Token.Token <> *Null);
             Dealloc #Token.Token;
           EndIf;
        EndFor;

        CTLST_Clear(#Instance.Strings);
        Return CS_SUCCESS;
      /End-Free

     P                 E
